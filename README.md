# ft_ping

</br>
</br>

## Socket

네트워크는 소켓으로 관리한다.

- 소켓이라는 단일한 인터페이스로 묶어서 사용.
- 네트워크를 초기화하여 다양한 통신 수단을 사용
- 운영체제의 파일시스템과 연동하여 구성.
- 상위에서 보면 파일처럼 다루어지게된다.
- 소켓에서는 socket()과 bind()라는 시스템콜 함수를 사용.

</br>
</br>

## Socket의 구현정보

- 정의:
  > 소켓 프로그램에 있어서 로컬호스트에서 실행되는 프로세스와 원격 호스트에서 실행되는 프로세스간에 데이터를 교환하기 위해 요구되는 정보.
- 종류
  > 프로토콜 식별자, 로컬 인터넷주소, 로컬번호, 원격인터넷주소, 원격포트번호로 구성
- 구현
  > 네트워크 드라이터(칩에 위치한 레지스터)는 주소설정, 전송 매개변수 변경, 소통량과 오류통계유지와 같은 상당수의 관리작업을 지원하도록 설계되어야한다.

</br>
</br>

## socket의 생성

</br>

### User

User영역에서의 인터페이스 사용

```c
sys_socket(family, type, potocol);

/*
family : AF_UNIX(localhost), AF_INET(internet), AF_IPX...
*/

/*
type: SOCK_STREAM(TCP), SOCK_DGRAM(UDP), SOCK_RAW(raw...)...
*/

```

</br>

### Kernel

kernel영역에서 소켓에해당하는 구조체를 할당하고 생성한다.

```c
socket_create();

->

socket_alloc()

->

struct socket {
    state
    type = SOCKET_STREAM
    flags
    ops = inet_stream_ops
    sk /*struct sock */
    files, inodes,
    nest, wait,
}

->

struct sock {
    family = PF_INET
    prot = tcp_prot
    net_pinfo
    tp_pinfo, socket
    sk_buff
    ...
}


```

</br>

## Socket 생성후 소켓 데이터 구조의 흐름

1. socket은 fd(식별자)로 다루어진다.
2. file system에 접근

```c
...
f_dentry
...
f_pos
f_op /* operation : dentry, d_inode로 연결
dentry, d_inode는 일종의 포인터역활 */

```

3. f_op( 추상화된 함수집합)을 통해서, 연결되어있는 소켓구조체의 파일로 접근

```c

struct socket {
    state
    type
    flags
    ops
    files, indoes /* 이곳으로 연결 */
    sk /* struct sock 으로 다시 연결 */
}

```

4. 다시한번 소켓 구조체에 연결

```c

struct sock {
    /* socket info */
    next, prev
    daddr, dport
    ...
    sk_buff /* 구조체  */
}
```

</br>

## ICMP

Internet Control Message Protocol

- 인터넷 프로토콜의 취약점

  > IP는 오류 보고와 오류 정정 메커니즘이 없음. 호스트와 관리 질의를 위한 메커니즘이 부족

- ICMP
  > 1.  인터넷 제어 메시지 프로토콜
  > 2.  IP의 약점을 보완
  > 3.  IP 데이터그램으로 캡슐화

### ICMP의 메세지 유형

- 오류보고 메시지 (error reporting)

  > 오류를 수정하지는 않고, 오류 보고만 수행한다. 해당 IP주소를 통하여 발신지에 오류 전송

- Query
  > 일부 네트워크 문제를 진단
  > 쿼리 메세지에서 type이 0 또는 8일때, ping 명령어에 쓰임.
  > 메세지는 Echo request 또는 reply이다.

</br>

## 네트워크 전송시 오류검출 방식

### Parity

> 정해진 위치에 잉여비트(parity 비트)를 추가하여, 홀/짝으로 오류검증

정보비트 잉여비트
101111 []

송 수신 쪽이 홀 또는 짝으로 약속을 한다.

예) 짝 일경우,

정보비트에서 1의 갯수를 가져온다. => 5
잉여비트를 합하여, 짝이되도록한다. 즉, 잉여비트는 1이된다.

101111[1] 을 보낸다.

수신측에서 짝을 확인한후, 수신.
만약
101110[1]로 온다면, 전송중에 데이터 오류가 발생했으므로, 재요청

- 장점: 많은 양의 데이터도 한개의 비트로 오류검출가능
- 단점: 만약 동시에 두개의 1이 0으로 변하거나, 0 이 1로변한다면, 오류검증이 제대로 되지않음.

</br>

### block sum check

> 정보비트의 1의 갯수를 2진법으로 바꾼후, 뒤에 2자리를 잉여비트를 붙여 비교한다.

예) 뒤에 2자리

1. 정보비트 : 10111010
2. 1의 갯수 : 5개, 이진수 : 0101
3. 뒤에 두자리 : 01
4. 전송비트 : 10111010+01
5. 수신측에서 정보비트를 가지고 잉여비트계산후 비교.

</br>

### check sum
> 송신측에서는 정보비트 블록을 일정하게(8비트) 나눈다.
> 나는 블록을 1의 보수연산을한후에, 1의보수를 구한값을 정보비트에 추가하여 송신
> 수신측에서는 전송받은 비트들을 다 1의 보수연산을한후에, 1의보수를 구하여, 값이 0이면 정상수신


#### 전송측
> 전송비트를 1의 보수연산으로 더한후, 1의 보수를 구한다.

예) 전송비트는 다음과같다 :

10111010
10001010
01000100

이 전송비트들을 더하면,

[1] 10001000 맨앞의 1은 오버플로우이므로, 뒤에 다시더한다(1의 보수연산)
10001000 + 1

: 10001001
이결과를 1의 보수로 만든다.
: 01110110
이러한 결과를 추가해서 보낸다.
즉, 전송비트는 다음과같다.

10111010 10001010 01000100 [01110110]

#### 수신측
> 전송받은 모든 비트열을 1의 보수연산으로 더한뒤, 1의보수를했을때 0이나오면 정상

10111010
10001010
01000100
01110110

연산값: 
11111110

오버플로우 1을 1의보수로 연산
11111111

1의 보수값: 
00000000

즉, 정상수신

</br>
</br>




